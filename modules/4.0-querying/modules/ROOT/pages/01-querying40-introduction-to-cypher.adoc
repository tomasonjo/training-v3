= Introduction to Cypher
:slug: 01-querying40-introduction-to-cypher
:doctype: book
:toc: left
:toclevels: 4
:imagesdir: ../images
:page-slug: {slug}
:page-layout: training
:page-quiz:
:page-module-duration-minutes: 105

ifndef::env-slides[]
== About this module

Cypher is the query language you use to retrieve data from the Neo4j Database, as well as create and update the data.


At the end of this module, you should be able to write Cypher statements to:

[square]
* Retrieve nodes from the graph.
* Filter nodes retrieved using labels and property values of nodes.
* Retrieve property values from nodes in the graph.
* Filter nodes retrieved using relationships.

Throughout this training, you should refer to:
[square]
* https://neo4j.com/docs/cypher-manual/current/[Neo4j Cypher Manual^]
* http://neo4j.com/docs/cypher-refcard/current/[Cypher Reference card^]

endif::[]

ifdef::env-slides[]
== In this module you'll learn ...
How to write Cypher statements to:

[square]
* Retrieve nodes from the graph.
* Filter nodes retrieved using labels and node property values.
* Retrieve node property values.
* Filter retrieved nodes using relationships.

Additional information is available from these sources:

[square]
* Neo4j Cypher Manual     (https://neo4j.com/docs/cypher-manual/current/)
* Cypher Reference card   (https://neo4j.com/docs/cypher-refcard/current/)


[.instructor-notes]
--
We’ll be starting slow and building up as we go.

* We’ll be looking at how to *retrieve nodes* from a *graph*,
* How to *filter* the *nodes* using *labels* and *properties*.
* How to *retrieve* node *properties* as output.
* And finally, how to use nodes and relationships together -
** to retrieve - complex structures that can be narrowly define.

Before we can do any of that,

* we need to talk a little bit about *Cypher*.

*<Show the students ...>*

 Neo4j Developer Manual:  https://neo4j.com/docs/cypher-manual/current/
 Cypher RefCard: https://neo4j.com/docs/cypher-refcard/current/

--
endif::[]

ifdef::env-slides[]
[.section-break]
== What is Cypher?
endif::[]

== What is Cypher?

ifndef::env-slides[]
Cypher is a declarative query language that allows for expressive and efficient querying and updating of graph data.
Cypher is a relatively simple and very powerful language.
Complex database queries can easily be expressed through Cypher, allowing you to focus on your domain instead of getting lost in the syntax of database access.

Cypher is designed to be a human-friendly query language, suitable for both developers and other professionals.
The guiding goal is to make the simple things easy, and the complex things possible.
endif::[]

ifdef::env-slides[]
[square]
* Declarative query language
** Focus on what and not how to retrieve data
* Used to:
** Query the graph
** Update the graph
* Easily-understood syntax
* Runs in the database instance

[.instructor-notes]
--
*Cypher* is a relatively simple and very powerful language.

* It’s used for querying and updating of graph data.
* Cypher is designed to be a human-friendly query language,
** suitable for both developers and other professionals.
* Cypher runs in the Neo4j database instance.


Cypher is a *declarative query language*.

* That is, - it focuses on *what* to retrieve and *not* how it is retrieved.
* By comparison to SQL, -
** In SQL - you can ask the same question using the same functions in a couple of different variations, -
** and you could get different performance and potentially a different answers.
* This is not the case when using Cypher.

Using Cypher ... you can ask the same question in three or four different ways;

* and you will get - not only the the *same answer* -
** but also *exactly the same processing steps*, which take place behind the scenes.
* This makes Cypher a much friendlier language for the developers - relative to SQL.
* We’ll see some examples of this as we go through the course.

However, Cypher will not be entirely unfamiliar for those that have used SQL.

* It uses a syntax that is broadly recognizable to those who use SQL.
* It has keyword operators followed by arguments and some of those operators are the same.
* For example, Cypher has *clauses* named *WHERE* and *WITH*.

Complex database queries can easily be expressed through Cypher, -

* allowing you to focus on your domain -
* instead of getting lost in the syntax of database access.

Cypher is a proprietary Neo4j language.

* *Neo4j* is one of the interested parties in developing *ANSI standard* for *graph databases*.
** (While it is not a available, it does have a name GQL (g-qual).)
* Neo4j is pushing for *Cypher* to be - largely - the basis of that language.
* However, for now it's just something that we provide as as part of Neo4j.

(The guiding goal is to make the simple things easy, and the complex things possible.)

--
endif::[]

=== Cypher is ASCII art

ifndef::env-slides[]
Optimized for being read by humans, Cypher's construct uses English prose and iconography (called ASCII Art) to make queries more self-explanatory.
endif::[]

ifdef::env-slides[]
Cypher's constructs use *English prose* and *iconography*.
endif::[]

image::ASCIIArtImage.png[ASCIIArtImage,width=150,align=center]

image::AsciiArt.png[AsciiArt,width=600,align=center]


ifdef::env-slides[]
[.instructor-notes]
--
Possibly - the most the most central feature of Cypher - is that it is highly visual.

* Cypher is intentionally made to look like ASCII art.
* It’s optimized for human readability.
* It makes queries somewhat self-explanatory.

Shown here are two different lines of Cypher that describe -

* a *3 node* - *3 relationship* - graph.

Without me telling you anything about Cypher -

* I imagine that  just by looking at this -
* you can see that the lines represent the sub-graph shown here.

--
endif::[]


=== Cypher expresses what to retrieve, not how to retrieve it

ifndef::env-slides[]
Being a declarative language, Cypher focuses on the clarity of expressing *what* to retrieve from a graph, not on *how* to retrieve it.
You can think of Cypher as mapping English language sentence structure to patterns in a graph.
For example, the nouns are nodes of the graph, the verbs are the relationships in the graph, and the adjectives and adverbs are the properties.
endif::[]

image::Nouns.png[Nouns,width=700,align=center]

ifndef::env-slides[]
This is in contrast to imperative, programmatic APIs for database access.
This approach makes query optimization an implementation detail instead of a burden on the developer, removing the requirement to update all traversals just because the physical database structure has changed.

Cypher is inspired by a number of different approaches and builds upon established practices for expressive querying.
Many of the Cypher keywords like `WHERE` and `ORDER BY` are inspired by SQL.
The pattern matching functionality of Cypher borrows concepts from SPARQL.
And some of the collection semantics have been borrowed from languages such as Haskell and Python.

The Cypher language has been made available to anyone to implement and use via openCypher (opencypher.org), allowing any database vendor, researcher or other interested party to reap the benefits of our years of effort and experience in developing a first class graph query language.
endif::[]

ifdef::env-slides[]
[.instructor-notes]
--
When combining this *visual syntax*, -

* with *carefully* chosen names for *labels* and *properties* -
* queries tend to be quite readable.

For example if we read what is shown here - we see -

* I want to find the person named Dan - who married on this date - the person named Ann.

This is in contrast to imperative, programmatic APIs for database access.

Are there any questions - about the abstract features of Cypher before we move on?

*Additional information on Cypher:*

* The pattern matching functionality of Cypher borrows concepts from SPARQL.
* Some of the collection semantics have been borrowed from languages such as Haskell and Python.
* The Cypher language has been made available to anyone to implement and use via openCypher (opencypher.org), allowing any database vendor, researcher or other interested party to reap the benefits of our years of effort and experience in developing a first class graph query language.

--
endif::[]

ifdef::env-slides[]
[.section-break]
== Cypher syntax
endif::[]

[.half-column]
== Node syntax

ifdef::env-slides[]
( )
(p)
endif::[]

ifndef::env-slides[]
Cypher uses a pair of parentheses like `()`, `(n)` to represent a node, much like a circle on a whiteboard.

Here is the simplified syntax for specifying a node:

[source,syntax,role=nocopy noplay]
----
()
(<variable>)
----

Notice that a node must have the parentheses.

When you specify `(n)` for a node, you are telling the query processor that for this query, use the variable _n_ to represent nodes that will be processed later in the query for further query processing or for returning values from the query.
If you do not need to do anything with the node, you can skip the use of the variable.
This is called an anonymous node.

Recall that a node typically represents an entity in your domain.
endif::[]

image::NodeSyntaxImage.png[NodeSyntaxImage,width=300,align=center]



ifdef::env-slides[]
[.instructor-notes]
--
Now let’s take a look at *node syntax* in Cypher.

Whenever you are trying to *do something* with a *node* in Cypher.

* The syntax - to *specify a node* - is an *open and closed parentheses*.
** Two examples are shown here.
* The parentheses represents a circle used for nodes in a whiteboard diagram -
** Such as the nodes shown in the diagram here.

Cypher uses a pair of parentheses like (), (n) to represent a node, much like a circle on a whiteboard.
When you specify (n) for a node, you are telling the query processor that for this query, use the variable n to represent nodes that will be processed later in the query for further query processing or for returning values from the query.

Recall that a node typically represents an entity in your domain. An anonymous node, (), represents one or more nodes during a query processing where there are no restrictions of the type of node or the properties of the node.

--
endif::[]

[.half-column]
== Label syntax

ifndef::env-slides[]
Nodes in a graph are typically labeled. Labels are used to group nodes and filter queries against the graph.
That is, labels can be used to optimize queries.
endif::[]

ifdef::env-slides[]
----
(:Person)
(p:Person)
(:Location)
(l:Location)
(x:Residence)
(x:Location:Residence)
----

[.instructor-notes]
--
We’ll start with *Labels* and how they are represented in Cypher.

* Nodes in a graph are typically labeled.
* *Labels* are used to *group nodes* and also to *filter queries* against the graph.
* Using labels provides one way to optimize queries by quickly identifying a group of nodes.
* In this diagram we see labels for *Person*, *Location* and *Residence*.

Each node can have zero or more labels, although there is almost always at least one label.

* In Cypher, when a Label specified it  *always starts* with a *colon*.
** As we can see here, there is a colon in each of the examples.
* Colon-Person represents the two Person nodes shown in the diagram.

A variable can also be associated with a node.

* For example, here the variable ‘p’ is used with label person.
* When a Cypher query is run the variable p is assigned to a set of nodes.
* Having this variable allows you to do things later, -
** such as displaying the retrieved set of nodes.

In the last line of sample syntax - there are 2 labels - *Location* and *Residence*.

* In Cypher you're not limited to searching for just one label at a time.
* This syntax with two labels, - specifies I want to find all nodes
** that have the label *Location* and the label *Residence*
* The returned set of nodes will be only nodes that are *doubly labeled* as both.
--
endif::[]

image::LabelSyntaxImage.png[NodeSyntaxImage,width=300,align=center]

ifndef::env-slides[]
In this example, the node labels are _Person_, _Location_, and _Residence_.

Here are examples for specifying nodes with labels using the the above image:

[source,syntax,role=nocopy noplay]
----
(:Person)
(p:Person)
(:Location)
(l:Location)
(x:Residence)
(x:Location:Residence)
----

Here we see nodes with variables and also anonymous nodes without variables. A node can be retrieved using one or more Labels.

In the _Movie_ database you will be working with in this course, the nodes in this graph are labeled _Movie_ or _Person_ to represent two types of nodes.
endif::[]

=== Comments in Cypher

ifndef::env-slides[]

In Cypher, you can place a comment (starts with `//`) anywhere in your Cypher to specify that the rest of the line is interpreted as a comment.
endif::[]

[source,syntax,role=nocopy noplay]
----
// anonymous node not be referenced later in the query
()
// variable p, a reference to a node used later
(p)
// anonymous node of type Person
(:Person)
// p, a reference to a node of type Person
(p:Person)
// p, a reference to a node of types Actor and Director
(p:Actor:Director)
----


ifdef::env-slides[]
[.instructor-notes]
--
Now let’s look at *comments* in Cypher.

* Two back slashes represent as comment, as shown here.
* The comments in this case provide a summary of the syntax that we just discussed.

Two points of note,

* You are not required to add labels or variables for a node.
* You can have a variable, without having a label.
* There is - *no theoretical upper limit* - to the *number of labels* - to which a node can belong.
** This is the case since a *label* is simply a *grouping of nodes*.

Are there any questions about the *syntax* for *nodes*?

A *commonly asked* question is –

Q: How can a new neo4j developer -

* gain an *understanding* of the *nodes* and *relationships* that exist in a given environment.

<ANSWER NEXT SLIDE>

--
endif::[]

== Examining the data model

ifndef::env-slides[]

When you are first learning about the data (nodes, labels, etc.) in a graph, it is helpful to examine the data model of the graph.
You do so by executing `CALL db.schema.visualization()`, which calls the Neo4j procedure that returns information about the nodes, labels, and relationships in the graph.

For example, when we run this procedure in our training environment, we see the following in the result pane.
Here we see that the graph has 2 labels defined for nodes, _Person_ and _Movie_.
Each type of node is displayed in a different color.
The relationships between nodes are also displayed, which you will learn about later in this module.

endif::[]

image::call_db.schema.visualization.png[call_db.schema.visualization,width=700,align=center]

ifdef::env-slides[]
[.instructor-notes]
--
When you are first learning about the data (nodes, labels, etc.) in a graph,

* it is helpful to examine the data model of the graph.

There’s a very useful *Cypher statement* that allows you to -

* view *all* the *labels* currently in use in a graph.
* As shown here the command is *CALL - ‘db dot schema dot visualization’*.
** (Note: Prior to 4.0 this command was *‘CALL db.schema’* )
* This calls the *Neo4j procedure* that returns information about -
** the *nodes*, *labels*, and *relationships* in the graph.
* This includes the relationship *direction between* the nodes.


Notice the relationship *FOLLOWS* points back to the same node, -

* since it’s a relationship between the nodes with the same label type, Person.
* The *relationships* between the *Person* and *Movie* nodes includes the *directed Types* -
** always *originating* at Person and going to Movie.

Using this command *comes in handy* -

* when you want to view a *snapshot* of the *generic structure* of your data.

The *name* of the command is a little *misleading* - since it uses the word *schema* -

* since *Neo4j* is *schema-less*.

So, if there’s *no schema* - how are we getting this data?

* This data is *not referencing* any kind of *schema*.
* What it is doing - is letting you know -
** the *current state* of your *graph*.

This could change at a moment's notice.

* This is the case -
** since any new data that’s added -
** may not fit this paradigm.
* Neo4j allows you to *create anything*, that is *any data*, -
** which doesn't match this current structure.

For example, you could add a *third label* or another *relationship*.

* If you then - called *‘DB dot schema visualization’* -
** it would immediately pick up on these changes and show you that version of the structure.

Therefore, this isn't the schema, in the sense of - a

* *prescriptive definition* of your *data model*.
* It’s a *description* - of what you have *currently* built.


<CODE: To run example>

:play https://guides.neo4j.com/4.0-intro-neo4j-exercises/01.html

Run code to - Delete existing graph - create Movie graph
--
endif::[]


ifdef::env-slides[]
[.section-break]
== MATCH and RETURN
endif::[]

ifndef::env-slides[]
== Syntax: Using MATCH and RETURN

////
ifdef::backend-html5[]

In this video, you will be introduced to using the `MATCH` statement to retrieve nodes from the graph in Neo4j Browser.

++++
<iframe width="560" height="315" src="https://www.youtube.com/embed/Sz2C618QKN8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
++++

endif::backend-html5[]
{nbsp} +

////


The most widely used Cypher clause is  `MATCH`.
The `MATCH` clause performs a pattern match against the data in the graph.
During the query processing, the graph engine traverses the graph to find all nodes that match the graph pattern.
As part of query, you can return nodes or data from the nodes using the `RETURN` clause.
The `RETURN` clause must be the last clause of a query to the graph.
In the course, _Creating Nodes and Relationships in Neo4j 4.x_, you will learn how to use `MATCH` to select nodes and data for updating the graph.
First, you will learn how to simply return nodes.


Syntax examples for a query:

[source,syntax,role=nocopy noplay]
----
MATCH (variable)
RETURN variable
----

[source,syntax,role=nocopy noplay]
----
MATCH (variable:Label)
RETURN variable
----

Notice that the Cypher keywords `MATCH` and `RETURN` are upper-case.
This coding convention is described in the _Cypher Style Guide_ and will be used in this training.
This `MATCH` clause returns all nodes in the graph, where the optional _Label_ is used to return a subgraph if the graph contains nodes of different types.
The _variable_ must be specified here, otherwise the query will have nothing to return.
endif::[]


===  Example: `MATCH` and `RETURN`


Retrieve all nodes:

[source,Cypher,role=noplay]
----
MATCH (n) 			// returns all nodes in the graph
RETURN n
----


ifdef::env-slides[]
[.instructor-notes]
--
Now that we’ve covered *node syntax*, let’s look at our first *Cypher statements*.

* In Cypher ... *MATCH* and *RETURN* clauses tend to be used in tandem.

The *MATCH* clause takes -  an argument - made up of a *pattern* that you're looking to find in the graph.

* In its *simplest form* - it is just a node, as shown here in the lower code box with variable n.
* There aren’t any filters, so this will - *MATCH* and *RETURN* - *every node* in the graph.

The *RETURN* clause provides the *output*

* The argument ‘n’ specifies the output to be returned.
* Which - in this case - returns the set of all nodes which is represented by variable ‘n’.

Again, It *returns* the *entire graph*

* That's something you probably won't do in production,
** but you may do that during your development and testing.

<more details>

The most widely used Cypher clause is MATCH. The MATCH clause performs a pattern match against the data in the graph. During the query processing, the graph engine traverses the graph to find all nodes that match the graph pattern. As part of query, you can return nodes or data from the nodes using the RETURN clause. The RETURN clause must be the last clause of a query to the graph. In the course _Creating Nodes and Relationships in Neo4j 4.x_, you will learn how to use MATCH to select nodes and data for updating the graph. First, you will learn how to simply return nodes.
Notice that the Cypher keywords MATCH and RETURN are upper-case. This coding convention is described in the Cypher Style Guide and will be used in this training. This MATCH clause returns all nodes in the graph, where the optional Label is used to return a subgraph if the graph contains nodes of different types. The variable must be specified here, otherwise the query will have nothing to return.

--
endif::[]

=== Example: Retrieve all _Person_ nodes

[source,Cypher,role=noplay]
----
MATCH (p:Person) 	// returns all Person nodes in the graph
RETURN p
----

ifndef::env-slides[]
When we execute the Cypher statement, `MATCH (p:Person) RETURN p`, the graph engine returns all nodes with the label _Person_.
The default view of the returned nodes are the nodes that were referenced by the variable _p_.

The result returned is:
endif::[]

image::PersonNodes-graph.png[PersonNodes-graph,width=700, align=center]

ifndef::env-slides[]
[NOTE]
When you specify a pattern for a `MATCH` clause, you should always specify a node label if possible. In doing so, the graph engine uses an index to retrieve the nodes which will perform better than not using a label for the `MATCH`.


One thing to notice in this example is that some of the displayed nodes are connected by the _FOLLOWS_ relationship.
The visualization shows the relationship between these nodes because we have specified *Connect result nodes* in our Neo4j Browser settings.
Some of the Person nodes represent people who reviewed Movies and as such, they follow each other.
endif::[]


ifdef::env-slides[]
[.instructor-notes]
--
Here’s a more realistic query, since we're applying a filter - using the label Person.

* You will likely always specify - *node labels* …
** since this - significantly improves performance and it is unlikely that you want to retrieve all nodes in a graph.

Here, we're matching - a single a node,  and we want to match only nodes with the label Person.

* This set is assigned to *variable ‘p’*.
* We finish - by returning *set ‘p’* - with all Person nodes in the graph.

Are there any questions about these two clauses?

By default, whenever you return a variable - that contains *Node objects*,

* you are going to get a *graph visualization* in the the Browser, as we see here

<more details>

When we execute the Cypher statement, MATCH (p:Person) RETURN p, the graph engine returns all nodes with the label Person. The default view of the returned nodes are the nodes that were referenced by the variable p.
One thing to notice in this example is that some of the displayed nodes are connected by the FOLLOWS relationship. The visualization shows the relationship between these nodes because we have specified Connect result nodes in our Neo4j Browser settings. Some of the Person nodes represent people who reviewed Movies and as such, they follow each other.
--
endif::[]

== Viewing nodes as table data

ifndef::env-slides[]
We can also view the nodes as table data where the nodes and their associated property values are shown in a JSON-style format.

When nodes are displayed as table values, the node labels and ids are also shown if you are using version 4.1 or later. Node ids are unique identifiers and are set by the graph engine when a node is created.
endif::[]

image::PersonNodes-table.png[PersonNodes-table,width=700,align=center]

ifdef::env-slides[]
[.instructor-notes]
--
The *graph visualization* - is one of *4 kinds* of *output* that Neo4j provides in *Neo4j Browser*.

The other three options include …

* *Table* output, which returns whatever you have requested in *Table* form.
** We can see an example of that shown here.
* The other two are *Text* and *Code*.

Please feel free to experiment with these when we do our first exercise.

In general - *Graph* and *Text* - output are good for human users,

* whereas the others tend to be for system usage.

<more details>

We can also view the nodes as table data where the nodes and their associated property values are shown in a JSON-style format. When nodes are displayed as table values, node labels and ids are also shown if you are using version 4.1 or later. Node ids are unique identifiers and are set by the graph engine when a node is created.null

--
endif::[]


[.student-exercise]
== Exercise 1: Retrieving nodes

[IMPORTANT]
Prior to performing this exercise, you should have set up your development environment to use one of the following, which is covered in the course, _Overview of Neo4j 4.x_.
[square]
* Neo4j Desktop
* Neo4j Sandbox
* Neo4j Aura

In the query edit pane of Neo4j Browser, execute the browser command:

kbd:[:play 4.0-intro-neo4j-exercises]

and follow the instructions for Exercise 1.

[NOTE]
This exercise has 4 steps.
Estimated time to complete: 10 minutes.

ifdef::env-slides[]
[.instructor-notes]
--
Note: Show students how to  *:play 4.0-intro-exercises* and how to navigate to *Exercise 1*.

They should have already populated the database from the *Neo4j Guided Exercise* in the course, _Overview of Neo4j 4.x_,
but if they have not, there is a script at the beginning of each Exercise to delete all nodes and re-populate the database.
*Note*: If students are using a *Sandbox*, they could run into access issues if they have an ad blocker, or on a VPN, or if certain ports are blocked.

<START HERE>

*We're going* to do our first *exercise*.
These *hands-on exercises* provide instructions that are available within Neo4j browser.

* I invite everybody to try doing these on their own.
* Please speak-up with any questions or difficulties.

Before you start ...  let me show you how these work.

* Your *Neo4j Desktop* should be active and running the *Movies database*, as we covered earlier.
* You should see that the database is active in the Desktop.
* You should open-up a Neo4j Browser.
* Execute the command - colon play intro dash exercises. (*:play 4.0-intro-exercises*)

This takes you to the guide that *introduces* these exercises.

* The first *three pages* are about environment setup.
* All of you have already done this.
** So, you should be able to skip through to the last page.

Here, you can see we have a *link* for *each* of the exercises.

* We’ll begin with the first one
* You'll see that there are several steps here.
* There's preparation to make sure your graph is in the needed state for the tasks.

There’s are number of *tasks*, you are asked to do.

* Most tasks are composed of a *pair* made of of *Instructions* and *Solutions*.
* You should read the instruction and try to answer the question.
* Whether or not you have an answer you should continue on to the answer page.
* There - check your answer - and run the answer code if your code didn’t work.
* It’s OK if you don’t get the code in the time allotted.
** You can always go back after class to hone your skills.
* By simply clicking in the solution code box - the code is replaced  with whatever is in the editor.

I invite all of you to try this on your own.

* We're going to take about *10 minutes* for this.
* When you're done, please let me know so I can track progress.
* I'll also be checking in about every five minutes or so.
* Please reach out if you have any difficulties or questions.

Alright, let's wrap up this exercise and move on to the next topic.
--
endif::[]

ifdef::env-slides[]
[.section-break]
== Properties
endif::[]


== Properties

ifndef::env-slides[]
In Neo4j, a node (and a relationship, which you will learn about later) can have properties that are used to further define a node.
A property is identified by its property key.
Recall that nodes are used to represent the entities of your business model.
A property is defined for a node and not for a type of node.
All nodes of the same type need not have the same properties.

For example, in the _Movie_ graph, all _Movie_ nodes have both _title_  and _released_ properties.
However, it is not a requirement that every _Movie_ node has a property, _tagline_.
endif::[]

image::MovieProperties.png[MovieProperties,width=600,align=center]

ifndef::env-slides[]
Properties can be used to filter queries  so that a subset of the graph is retrieved.
In addition, with the `RETURN` clause, you can return property values from the retrieved nodes, rather than the nodes.
endif::[]

ifdef::env-slides[]
[.instructor-notes]
--
Now you have some hands-on experience with Cypher.

* You're starting to use a couple of keywords and you’ve starting to work with nodes.

So far, we've only worked with *node labels*.

* But as we've discussed, labels are not the only kind of information that nodes can contain.
* They can also contain *properties*.
* And what's interesting is that even nodes that have the same label,  -
** *do not necessarily* have all of the *same* properties.
* This is part of being fully schema-less.

Here we see *three Nodes* that all have the label - *Movie*.

* All of them have a - *title* and a *released* property, -
** but some of have a *tagline* property and some do not.

You can also see that - while all of them share the same *Movie* - *label* ...

* because labels are *categorical*, -- the specifics of their property values are - entirely distinct.
* *Labels* are *general* - and *properties* are *specific*.

The logical question here is - How do we go about using properties in Cypher?

* Before we talk about how we use Cypher with properties, just as we did for labels, …
** We'll start with - how can I know - what - property keys - are available in the graph database?

<more details>

For example, in the Movie graph, all Movie nodes have both title and released properties. However, it is not a requirement that every Movie node has a property, tagline.

In Neo4j, a node (and a relationship, which you will learn about later) can have properties that are used to further define a node. A property is identified by its property key. Recall that nodes are used to represent the entities of your business model. A property is defined for a node and not for a type of node. All nodes of the same type need not have the same properties.
Properties can be used to filter queries so that a subset of the graph is retrieved. In addition, with the RETURN clause, you can return property values from the retrieved nodes, rather than the nodes.

--
endif::[]

[.half-column]
=== Examining property keys

ifndef::env-slides[]
As you prepare to create Cypher queries that use property values to filter a query, you can view the values for property keys of a graph by simply clicking the Database icon in Neo4j Browser.
Alternatively, you can execute  `CALL db.propertyKeys()`,  which calls the Neo4j library method that returns the property keys for the graph.

Here is what you will see in the result pane when you call the method to return the property keys in the _Movie_ graph.
This result stream contains all property keys in the graph. It does not display which nodes utilize these property keys.
endif::[]


ifdef::env-slides[]

----
CALL db.propertyKeys()
----

[.instructor-notes]
--
There is a database - call - to provide information on property keys.

* It is called *db.propertyKeys*.
* This will show you *every property key* that exists in your *graph*.

There is a limitation with this command:

* This *does not tell* you which of these properties -  tend to be *properties* of - *Nodes*,
** versus which of them tend - to be *properties* of - *relationships*.

It also does not tell you what, if any *correlations* -

* there are between *certain labels*, having *certain properties*.

The reason for that - is an *implementation question*

* All properties are considered all the same.
* They’re not differentiated in anyway.
* It's simply that a *node* or a *relationship*  -will *link* to the properties that *it uses*.

As a naming consideration, in order to make db.propertyKeys and other areas easier to use.

* It is recommended that you *choose property key* names that are somewhat descriptive.
* For example, as shown in this list of properties,  *People* have *names*,
** but *Movies* have *titles*,
** *People* are *born* on a *certain date*, while *Movies* are *released* on a *certain date*.

This command will return all of properties in the graph, and just as for db.schema, it is fast because it is using the count store.

Any questions about property keys?

*Q*: Does that mean we cannot have two properties, one defined for a Node and another for a Relationship with the same property key name?

*A*: You can do that.  You can *use* the *very same property* on both - a *node* and a *relationship*.
To go beyond this, it is recommended that if you are using the same property key in different places in the graph that you be consistent on how that property is used.

*Q*: Is possible to return just properties for Nodes, verses for Relationships?

*A*: Yes, you can do that.  However it is a lot harder.
To do that involves going to the graph and retrieving a bunch of Nodes an outputting the set of properties that they have.
It is going to be - a much more expensive operation.

<more details>

Here is what you will see in the result pane when you call the method to return the property keys in the Movie graph. This result stream contains all property keys in the graph. It does not display which nodes utilize these property keys.

As you prepare to create Cypher queries that use property values to filter a query, you can view the values for property keys of a graph by simply clicking the Database icon in Neo4j Browser. Alternatively, you can execute CALL db.propertyKeys(), which calls the Neo4j library method that returns the property keys for the graph.
--
endif::[]


image::call_db.PropertyKeys.png[call_db.PropertyKeys,width=600,align=center]

ifndef::env-slides[]
== Syntax: Retrieving nodes filtered by a property value

You have learned previously that you can filter node retrieval by specifying a label.
Another way you can filter a retrieval is to specify a value for a property.
Any node that matches the value will be retrieved.

Here are  simplified syntax examples for a query where we specify one or more values for  properties that will be used to filter the query results and return a subset of the graph:

[source,syntax,role=nocopy noplay]
----
MATCH (variable {propertyKey: propertyValue})
RETURN variable
----

[source,syntax,role=nocopy noplay]
----
MATCH (variable:Label {propertyKey: propertyValue})
RETURN variable
----

[source,syntax,role=nocopy noplay]
----
MATCH (variable {propertyKey1: propertyValue1, propertyKey2: propertyValue2})
RETURN variable
----

[source,syntax,role=nocopy noplay]
----
MATCH (variable:Label {propertyKey: propertyValue, propertyKey2: propertyValue2})
RETURN variable
----
endif::[]

[.half-column]
=== Example: Filtering query by year born

[.instructor-notes]
--
Here is an example where we filter the query results using a property value.
We only retrieve _Person_ nodes that have a _born_ property value of _1970_.
--

[source,Cypher,role=noplay]
----
MATCH (p:Person {born: 1970})
RETURN p
----

ifndef::env-slides[]
The result returned is:
endif::[]

image::MatchPersonBorn1970.png[MatchPersonBorn1970,width=600, align=center]

[.half-column]
=== Example: Filtering query by multiple properties

ifndef::env-slides[]
Here is an example where we specify two property values for the query.
endif::[]

[source,Cypher,role=noplay]
----
MATCH (m:Movie {released: 2003, tagline: 'Free your mind'})
RETURN m
----

ifndef::env-slides[]
Here is the result returned:
endif::[]

image::TwoPropertiesForFilter.png[TwoPropertiesForFilter,width=700,align=center]

ifndef::env-slides[]
As it turns out, there is only one movie with the _tagline_, 'Free your mind` in the _Movie_ database. If we had specified a different year, the query would not have returned a value because when you specify properties, both properties must match.
endif::[]


ifdef::env-slides[]
[.instructor-notes]
--
Just as you can look for *multiple labels* on a single node,

* You can do the same with properties.
* As shown here, this is done - using a *comma* - to separated the *properties*, within your *curly braces*.

Here we're looking for Nodes with the label *Movie* - being *released* in *2003* ...

* and *also* having - the  *tagline* of *‘free your mind’*.

This is a very specific request, - and it's not surprising - that only one node was returned.

* That node is for the movie - 'The Matrix Reloaded'.

Are there any questions - about using properties as a filter?

*Q*: What characters can be used in a property key?

*A*: Property keys can only be composed of alpha numeric.

*Q*: What types of logic can be done beyond AND in a MATCH.

*A*: The filters available in-line in MATCH are extremely limited. They're there for usability and readability.
We’ll be seeing - how to use - a WHERE clause, that provides flexibility, later in this course.


*Q*: Are *properties* data type *specific*?
*A*: *They are not* data type specific. This again goes back to the schema-less nature of Neo4j.

* *Properties* themselves are also *ungoverned* by any type of schema. *Properties* are are *not typed*.
* You can include *any* data type you want in a property, and *not necessarily* even *consistently* ...
* with the same type - for the same property name - from one place to another.

Here you can see *tagline* is a *string*, as evidenced by the fact that - it has those *quotes*.

* *2003* - does not, so it's being treated as an *integer*.
* And if I were to put quotes around 2003.  This would *no longer match* the *same* data type
* because I'm *looking for* a *string* value - and *comparing* it to *integers*.

The question then comes up - *How* do you address that? *How* do you do data governance?

* *Data governance* is something that is *captured*, - when you are doing your *data load*.
* *Neo4j* is *not* - going to *enforce* - that you use only integers, in the *released property*,
* But you can - *upon data load*, - do a *cast* - to make sure that every entry for a given property has the same datatype.

<more details>

Here is an example where we specify two property values for the query.
As it turns out, there is only one movie with the tagline, 'Free your mind` in the Movie database. If we had specified a different year, the query would not have returned a value because when you specify properties, both properties must match.

--
endif::[]

ifndef::env-slides[]
== Syntax: Returning property values

////
ifdef::backend-html5[]

In this video, you will see how to return property values to the output stream when you retrieve nodes from the graph in  Neo4j Browser.

++++
<iframe width="560" height="315" src="https://www.youtube.com/embed/Nb9tSFVrQuc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
+++

endif::backend-html5[]
{nbsp} +

////

Thus far, you have seen how to retrieve nodes and return nodes (entire graph or a subset of the graph).
You can use the `RETURN` clause to return property values of nodes retrieved.

Here are simplified syntax examples for returning property values, rather than nodes:

[source,syntax,role=nocopy noplay]
----
MATCH (variable {prop1: value})
RETURN variable.prop2
----

[source,syntax,role=nocopy noplay]
----
MATCH (variable:Label {prop1: value})
RETURN variable.prop2
----

[source,syntax,role=nocopy noplay]
----
MATCH (variable:Label {prop1: value, prop2: value})
RETURN variable.prop3
----

[source,syntax,role=nocopy noplay]
----
MATCH (variable {prop1:value})
RETURN variable.prop2, variable.prop3
----
endif::[]

[.half-column]
=== Example: Returning property values

ifndef::env-slides[]
In this example, we use the _born_ property to filter the query, but rather than returning the nodes, we return the _name_  and _born_ values for every node that satisfies the query.
endif::[]

[source,Cypher,role=noplay]
----
MATCH (p:Person {born: 1965})
RETURN p.name, p.born
----

ifndef::env-slides[]
The result returned is:
endif::[]

image::MatchPersonBorn1965.png[MatchPersonBorn1965,width=800,align=center]

ifdef::env-slides[]
[.instructor-notes]
--
On the *previous slide* we saw how to use - *properties* as *filters* - in-line - in a MATCH clause.

* Properties can also be returned as output, as opposed to returning nodes.
* This is useful since there are many times where the entire *node object* does not need to be returned.
* This is used to return some of the data - in the node.

Using MATCH and RETURN -

* We want to look for all person Nodes, born in 1965.
* We're just returning *p dot name* and *p dot born*
* In other words, the *set* of *all* name properties -
** and *all* born properties for the selected p nodes.

Whenever you return properties, the *Table style* is used to display the output -

* instead of the Nodes - that we've been looking at in the other examples.
* As we can see here, there is a table of names and birth years returned.

We can make this output look a little better.

* Note that the column headings - are simply the names of the returned variables.

<more details>

In this example, we use the born property to filter the query, but rather than returning the nodes, we return the name and born values for every node that satisfies the query.
--
endif::[]

ifndef::env-slides[]
=== Syntax: Specifying aliases for column headings

If you want to customize the headings for a table containing property values, you can specify *aliases* for column headers.

Here is the simplified syntax for specifying an alias for a property value:

[source,syntax,role=nocopy noplay]
----
MATCH (variable:Label {propertyKey1: propertyValue1})
RETURN variable.propertyKey2 AS alias2
----

[NOTE]
If you want a heading to contain a space between strings, you must specify the alias with the back tick _`_ character, rather than a single or double quote character. In fact, you can specify any variable, label, relationship type, or property key with a space also by using the back tick _`_ character.
endif::[]

[.half-row]
=== Example: Specifying an alias for column headings

ifndef::env-slides[]
Here we specify aliases for the returned property values:
endif::[]

[source,Cypher,role=noplay]
----
MATCH (p:Person {born: 1965})
RETURN p.name AS name, p.born AS `birth year`
----

ifndef::env-slides[]
The result returned is:
endif::[]

image::UsingAliases.png[UsingAliases,width=800,align=center]


ifdef::env-slides[]
[.instructor-notes]
--
We can set the names of the columns - in RETURN - by using *AS* and specifying a name.
This example use AS to set *column headings* to *name* and *birth year*.
And we see better looking column names.
Please take note - the *back tic* - *MUST* be used in the RETURN statement for column labels.

*Q*: Why are the *names* shown in double quotes?

*A*: Strings are shown in *double quotes*.
*Neo4j* is a *platform* built on *Java*, so it *follows* all the *conventions* used in Java.
One those conventions is always - wrapping strings in quotes.

*Q*:  So does that mean that for properties - which are of type array - or character
 that it will do single quotes - versus square brackets and curly braces.

*A*: The answer is yes. However this is very rare.
Generally when a character is used as a datatype you most often see strings.
--
endif::[]

[.student-exercise]
== Exercise 2: Filtering queries using property values

In the query edit pane of Neo4j Browser, execute the browser command:

kbd:[:play 4.0-intro-neo4j-exercises]

and follow the instructions for Exercise 2.

[NOTE]
This exercise has 6 steps.
Estimated time to complete: 15 minutes.

ifdef::env-slides[]
[.instructor-notes]
--
It’s time for our 2nd exercise.

* Again, in the browser guides, -  under -  *:play 4.0 intro-exercises*, -  go to the *last page*.
* Now we're doing an *Exercise 2*
* The *purpose* of this exercise is to *expand* on what we did in the last one.
* We're going to start by working with *properties* both as *filters* and *outputs*.
* Again *solely* working with *Node objects*.
* We're going to work on this Exercise for about *15 minutes*.

Once you have finished, please let me know, -  also please speak up if you have questions or difficulties.

All right, everybody. We’re going to wrap up this exercise.

* You've had a chance now to work with nodes a fair amount.
* We did some label filtering.
* We've also done some property filtering and output individual properties.

--
endif::[]

ifdef::env-slides[]
[.section-break]
== Relationships
endif::[]

[.half-column]
== Relationships

ifndef::env-slides[]
Relationships are what make Neo4j graphs such a powerful tool for connecting complex and deep data.
A relationship is a *directed* connection between two nodes that has a *relationship type* (name).
In addition, a relationship can have properties, just like nodes.
In a graph where you want to retrieve nodes, you can use relationships between nodes to filter a query.
endif::[]

ifdef::env-slides[]
[square]
* Directed connection between two nodes.
* Relationships have a type (name).
* Relationships can have properties, just like nodes.
* Relationships are key to traversing a graph.
endif::[]

image::RelationshipsImage.png[RelationshipsImage,width=400,align=center]


ifdef::env-slides[]
[.instructor-notes]
--
We've done a lot of useful work with *Cypher*, -

* but we've been *missing* a *key component*.
* We haven't done anything at all yet with *Relationships*.

First a quick review …

* Relationships are a directed connection - always between 2 nodes.
* Relationships always have a - type.
* Just like nodes, relationships have properties.
* And - without relationships nothing can happen.
** Relationships are how we traverse the graph to answer questions.

As we did with nodes - we are first going to talk about - generic syntax for Relationships.
--
endif::[]

=== ASCII art

ifndef::env-slides[]
Thus far, you have learned how to specify a node in a `MATCH` clause.
You can specify nodes and their relationships to traverse the graph and quickly find the data of interest.


Here is how Cypher uses ASCII art to specify the path used for a query:
endif::[]

[source,syntax,role=nocopy noplay]
----
()          // a node
()--()      // 2 nodes have some type of relationship
()-[]-()    // 2 nodes have some type of relationship
()-->()     // the first node has a relationship to the second node
()<--()     // the second node has a relationship to the first node
----

ifdef::env-slides[]
[.instructor-notes]
--
Just as a node uses the *syntax* - of open and closed parentheses - ...

* and is intended to *represent* a circle.
* The *ASCII art* for *relationship* - uses an *arrow* representation, as we can see here.

Arrows are represented with  ...

* *Two dashes* and an *arrowhead*,
* This can point either to the right or to the left.

If you're asking a question - where the *direction* is *unimportant*, ...

* *or* - you specifically want to *look* in *both directions*, ...
* You can use a *double dash* with *no Arrowhead*.
* This *MATCH’s* relationships in both directions.

However, In your queries, make sure to include a direction whenever you can.

* This assures that the query will be more - performant.
* However, there are times - when an undirected query …
** is something - you'll need to get the desired data.

Are there any questions on this topic?

Thus far, you have learned how to specify a node in a MATCH clause. You can specify nodes and their relationships to traverse the graph and quickly find the data of interest.

--
endif::[]

ifndef::env-slides[]
== Syntax: Querying using relationships

In your `MATCH` clause, you specify how you want a relationship to be used to perform the query. The relationship can be specified with or without direction.

Here are simplified syntax examples for retrieving a set of nodes that satisfy one or more directed and typed relationships:
endif::[]

ifdef::env-slides[]
== Using relationships in a query
endif::[]

[source,syntax,role=nocopy noplay]
----
MATCH (node1)-[:REL_TYPE]->(node2)
RETURN node1, node2
----

[source,syntax,role=nocopy noplay]
----
MATCH (node1)-[:REL_TYPEA | REL_TYPEB]->(node2)
RETURN node1, node2
----

ifndef::env-slides[]
_where:_
{set:cellbgcolor:white}
[frame="none",,width="80%"cols="20,80",stripes=none]
|===
|_node1_
|is a specification of a node where you may include node labels and property values for filtering.
|_REL_TYPE_
|is the type (name) for the relationship. For this syntax the relationship is from _node1_ to _node2_.
|_REL_TYPEA_ , _REL_TYPEB_
|are the relationships from _node1_ to _node2._ The nodes are returned if at least one of the relationships exists.
|_node2_
|is a specification of a node where you may include node labels and property values for filtering.
|===
{set:cellbgcolor!}
endif::[]


ifdef::env-slides[]
[source,syntax,role=nocopy noplay]
----
MATCH (p:Person)-[:LIVES_AT]->(h:Residence)
RETURN p.name, h.address
----

[source,syntax,role=nocopy noplay]
----
MATCH (p:Person)--(h:Residence)  // any relationship
RETURN p.name, h.address
----

image::RelationshipsImage.png[RelationshipsImage,width=400,align=center]

[.instructor-notes]
--
Just as with nodes - You can *apply* any number of filters and specifiers on relationships.

On this slide we see both syntax, on the top, and query examples, on the bottom, of this slide.

To add a *type filter* on a relationship,

* a double dashed arrow, with a set of *square brackets*, ....
** in between the two dashes - is used. as we can see here.
* Within those *square brackets*, this is meant to represent - a *placard*  - sitting over the top of the *arrow*.
* There - you can put in *whatever specifiers* - you'd like for your query.

Here, for example, we just want to *match* any *Person node* ...

* that has a *LIVES_AT* *relationship* - with any *Residence node*.
* Looking at the example shown here - it will return all of the nodes, -
** 2 Person in variable 'p', and 1 Residence in variable 'h'.

A more generic way - that appears to return the same data, is the query shown in the lower box.

* *Any* Person node - that has *any* relationship - in *any* direction - with *any* Residence node.
* The nodes that we get will appear to be the same.
* We'll get one pattern that has this blue Person, and this Residence ...
* And then we'll get this orange Person and the same Residence.
* But there are some *differences*.
* First of all, we will get this orange Person twice, and the Residence three times.

*Why* is this??

* This happens because we have a dual relationship between the Orange person and the Residence.

We have two relationships between the Orange person and the Residence.

* By *default* whenever you're working with a *graph* – you’re working with *patterns* and *structures*,
* It is *Not* sets of nodes, and *Not* sets of relationships, -- --  But *entire structures*.
* Therefore, the actual *result* that you get - for this *match clause* - Is three objects (structures),
* You have *person blue - lives* at location, *person orange - lives at* location,
** and *person orange - owns* location.
* Each of the 3 structure are considered *distinct* -
** because they have *at least one item* that they *do not share*.
      (THIS IS IMPORTANT – since there are *3 patterns*.  *NOT sets*. )

This *thinking* of in terms of *structures* and *patterns* rather than *sets*, -

* is one of the consistent *‘graphy’ types of shifts* we need to *make* in our *thinking°.

Are there any questions so far about these relationships?

(*Note*: The *second query* produces *duplicate data* since there are three relationships here. We cover *DISTINCT* later in the course.)

<more details>

In your MATCH clause, you specify how you want a relationship to be used to perform the query. The relationship can be specified with or without direction. Here are simplified syntax examples for retrieving a set of nodes that satisfy one or more directed and typed relationships:

--
endif::[]

[.half-column]
== Examining relationships

ifndef::env-slides[]
You can run `CALL db.schema.visualization()` to view the relationship types in the graph.
In the _Movie_ graph, we see these relationships between the nodes.

Here we see that this graph has a total of 6 relationship types between the nodes. Some _Person_ nodes are connected to other _Person_ nodes using the _FOLLOWS_ relationship type.
All of the other relationships in this graph are from _Person_ nodes to _Movie_ nodes.
endif::[]

image::call_db.schema-relationships.png[call_db.schema-relationships,width=500,align=center]

ifdef::env-slides[]

----
CALL db.schema.visualization()
----

[.instructor-notes]
--
Recall earlier that I showed a way to see all of the *node* and *labels* in a graph.

* This same command also shows the relationships.
* This is done using the same command, and with the same output using …
* *CALL db.schema.visualization*

You - can use the displayed information - to see all of the available relationships.

* As we can see here, it shows both the type and the *direction*.
* This lets you know what is available for use in your *query filters*.

Now let's take a look at some examples.

<more details>

Here we see that this graph has a total of 6 relationship types between the nodes. Some Person nodes are connected to other Person nodes using the FOLLOWS relationship type. All of the other relationships in this graph are from Person nodes to Movie nodes.

--
endif::[]


== Using a relationship in a query

ifndef::env-slides[]
Here is an example where we retrieve the _Person_ nodes that have the _ACTED_IN_ relationship to the _Movie_, _The Matrix_.
In other words, show me the actors that acted in _The Matrix_.
endif::[]

[source,Cypher,role=noplay]
----
MATCH (p:Person)-[rel:ACTED_IN]->(m:Movie {title: 'The Matrix'})
RETURN p, rel, m
----

ifndef::env-slides[]
The result returned is:
endif::[]

image::ActorsInMatrix.png[ActorsInMatrix,width=800,align=center]

ifndef::env-slides[]
For this query, we are using the variable _p_ to represent the _Person_ nodes during the query, the variable _m_ to represent the _Movie_ node retrieved, and the variable _rel_ to represent the relationship for the relationship type, _ACTED_IN_.
We return a graph with the _Person_ nodes, the _Movie_ node and their _ACTED_IN_ relationships.
endif::[]

ifdef::env-slides[]
Find all people who acted in the movie 'The Matrix' and return the nodes and relationships.

[.instructor-notes]
--
Let's suppose that we want to - ‘find all the people who acted in the Matrix’.

* We're *looking* for a *certain structure*.
* That *structure* is for all *Person nodes* that have a ACTED-IN relationship *directed* at a *Movie node*.
* And not just any Movie node, - but a *movie* - that has a *title property* of 'The Matrix'.

We want to *RETURN* - all of those *people*, - all of those *relationships*, and all of those *movies*.

* The query yields the output shown here.

Are there any questions about this query?

*Q*: What areas require spaces in this query?

*A*: In general spaces are non-functional.

* However, a space is *required* between *function words* and *arguments*,
* and between the* property key* and *value*.

(*Note*: *Emphasize* the importance of specifying the node labels once again.)

<more details>

Here is an example where we retrieve the Person nodes that have the ACTED_IN relationship to the Movie, The Matrix. In other words, show me the actors that acted in The Matrix.
For this query, we are using the variable p to represent the Person nodes during the query, the variable m to represent the Movie node retrieved, and the variable rel to represent the relationship for the relationship type, ACTED_IN. We return a graph with the Person nodes, the Movie node and their ACTED_IN relationships.

--
endif::[]

ifndef::env-slides[]
=== Specify labels whenever possible

*Important:* You specify node labels whenever possible in your queries as it optimizes the retrieval in the graph engine.
That is, you should *not* specify the previous query as:

[source,Cypher,role=noplay]
----
MATCH (p)-[rel:ACTED_IN]->(m {title:'The Matrix'})
RETURN p,m
----
endif::[]

== Querying by multiple relationships

ifndef::env-slides[]
Here is another example where we want to know the movies that _Tom Hanks_ acted in or directed:
endif::[]


[source,Cypher,role=noplay]
----
MATCH (p:Person {name: 'Tom Hanks'})-[:ACTED_IN|DIRECTED]->(m:Movie)
RETURN p.name, m.title
----

ifndef::env-slides[]
The result returned is:
endif::[]

image::TomHanksActedDirected.png[TomHanksActedDirected,width=700,align=center]

ifndef::env-slides[]

Notice that there are multiple rows returned for the movie, _That Thing You Do_. This is because _Tom Hanks_ acted in and directed that movie.
endif::[]


ifdef::env-slides[]
Find all movies that Tom Hanzks acted in or directed and return the titles of the movies.

[.instructor-notes]
--
Just as we discussed for labels, where you can *look for *multiple labels* attached to a single node.

* You can also *look* for *multiple relationships* at once.
* This query provides an example of this.
* We’re looking for relationships that either have an - ACTED-IN or DIRECTED relationship.

However, to be clear, a given *relationship always* has only *one type*.

* In reference to this example - a *relationship* can have either *ACTED_IN* or *DIRECTED* type.

Another point I want to make on this slide is the Boolean OR that is used between the types.

* This is represented with the ‘pipe’ character.
* This is one of the *few cases* - where you can do a *Boolean match* in a *relationship*.

In - the context - of this *query*  ... we want to find all the *movies* that *‘Tom Hanks’* ...

* has either - ACTED_IN *or* DIRECTED.
* It will return a *pattern* - for each *ACTED_IN match* - and one for each *DIRECTED match*.

This query yields  the output shown here.

* If you look close - you’ll notice that the *movie* - ‘That Thing You Do’ is *repeated*.
** This is the case - since there is a relationship for *both* ACTED_IN and DIRECTED for Tom Hanks.
* The *reason* this is *repeated* - is that - we are *not* working with *sets of data*!
** *Instead* we are returning *patterns of data* -
** and it is *repeated* in *two patterns* based on the query.

Q: How did we know to look for this?

A: We can look back at the previous slide ... with *db.schema.visualization()*.

* We can see that there's a *DIRECTED* relationship,
* Also note that these relationships always point in the direction
** from *Person node* to *Movie node*.
* So the structure we’re looking for is available to us.
* However, it does not provide specifics, such as - Tom Hanks.

(*Note*: Prior to versions supported syntax  [:ACTED_IN | :DIRECTED] which is now *deprecated*. )
(*Note*: pipe | is a reserved operator.)

<more details>

Here is another example where we want to know the movies that Tom Hanks acted in and directed:
Notice that there are multiple rows returned for the movie, That Thing You Do. This is because Tom Hanks acted in and directed that movie.

--
endif::[]

== Using anonymous nodes in a query

ifndef::env-slides[]
Suppose you wanted to retrieve the actors that acted in _The Matrix_, but you do not need any information returned about the _Movie_ node.
You need not specify a variable for a node in a query if that node is not returned or used for later processing in the query.
You can simply use the anonymous node in the query as follows:
endif::[]

[source,Cypher,role=noplay]
----
MATCH (p:Person)-[:ACTED_IN]->(:Movie {title: 'The Matrix'})
RETURN p.name
----

ifndef::env-slides[]
The result returned is:
endif::[]

image::AnonymousMovieNode.png[AnonymousMovieNode,width=800,align=center]

ifndef::env-slides[]
[NOTE]
A best practice is to place named nodes (those with variables) before anonymous nodes in a `MATCH` clause.
endif::[]

ifdef::env-slides[]
Find all people who acted in the move 'The Matrix' and return their names.
[.instructor-notes]
--
In this example we want to find all people who have an - *ACTED_IN - type* of - *relationship* with the movie *'The Matrix'*.

A *best practice*  - is to place *named Nodes* - before *anonymous nodes* in a *MATCH* clause.

* In this example *‘p’* is specified for Person node,  -
** while there is *no variable* specified - for the *Movie* node.

Another *best practice* - is to *not specify* any unused variables.

A best practice is to place named nodes (those with variables) before anonymous nodes in a MATCH clause.

<more details>

Suppose you wanted to retrieve the actors that acted in The Matrix, but you do not need any information returned about the Movie node. You need not specify a variable for a node in a query if that node is not returned or used for later processing in the query. You can simply use the anonymous node in the query as follows:

--
endif::[]


== Using an anonymous relationship for a query

ifndef::env-slides[]
Suppose you want to find all people who are in any way connected to the movie, _The Matrix_.
You can specify an empty relationship type in the query so that all relationships are traversed and the appropriate results are returned.
In this example, we want to retrieve all _Person_ nodes that have any type of connection to the _Movie_ node, with the _title_, _The Matrix_.
This query returns more nodes with the relationships types, _DIRECTED_, _ACTED_IN_, and _PRODUCED_.
endif::[]

[source,Cypher,role=noplay]
----
MATCH (p:Person)-->(m:Movie {title: 'The Matrix'})
RETURN p, m
----

ifndef::env-slides[]
The result returned is:
endif::[]

image::AllRelationshipsMatrix.png[AllRelationshipsMatrix,width=800,align=center]

ifdef::env-slides[]
Find all people who have any type of relationship to the movie ‘The Matrix’, and return the nodes and relationships.
[.instructor-notes]
--
In this example we want to find *all people* who have *ANY* type of relationship with ‘The Matrix’.

So we're going to use a *fully anonymous relationship* , which doesn’t have - a relationship type - specified.

* *Any person* - with any *relationship* - in the *direction* of the Movie node, with a movie called ‘The Matrix’,  is returned.
* As shown here, a several *Person nodes* are returned.
* You can see by *inspection* - that they have *different kinds* of relationships - including -
** *ACTED_IN*, *DIRECTED*, and *PRODUCED* .

This type of graph inspection - is not something you could do - to feed data into a client application.

* For example if this query is part of a broader solution - where you want to act upon the differences - in the relationship type -
** you'd want to - *output* the *relationship types*.

(*Note*: In this training, we will use `-->`, `--`, and `<--` to represent anonymous relationships as it is a Cypher best practice.)

<more details>

Suppose you want to find all people who are in any way connected to the movie, The Matrix. You can specify an empty relationship type in the query so that all relationships are traversed and the appropriate results are returned. In this example, we want to retrieve all Person nodes that have any type of connection to the Movie node, with the title, The Matrix. This query returns more nodes with the relationships types, DIRECTED, ACTED_IN, and PRODUCED.

--
endif::[]


=== More anonymous relationships

ifndef::env-slides[]
Here are other examples of using the anonymous relationship:
endif::[]

[source,Cypher,role=noplay]
----
MATCH (p:Person)--(m:Movie {title: 'The Matrix'})
RETURN p, m
----

[source,Cypher,role=noplay]
----
MATCH (p:Person)-[]-(m:Movie {title: 'The Matrix'})
RETURN p, m
----

[source,Cypher,role=noplay]
----
MATCH (m:Movie)<--(p:Person {name: 'Keanu Reeves'})
RETURN p, m
----

ifndef::env-slides[]
In this training, we will use `+-->+`, `--`, and `+<--+` to represent anonymous relationships as it is a Cypher best practice.
endif::[]


ifdef::env-slides[]
It is recommended that empty brackets [] not be used
[.instructor-notes]
--
Here are some additional examples of using the anonymous relationship.

* These variations show a *double dash*, a *directed arrow* with a double dash,
** and an *empty bracket* between dashes.

It is recommended that empty brackets not be used, since they don’t add anything additional to the query.

--
endif::[]

== Retrieving the relationship types


There is a built-in function, `type()` that returns the type of a relationship.

ifndef::env-slides[]
Here is an example where we use the _rel_ variable to hold the relationships retrieved.
We then use this variable to return the relationship types.
endif::[]

[source,Cypher,role=noplay]
----
MATCH (p:Person)-[rel]->(:Movie {title:'The Matrix'})
RETURN p.name, type(rel)
----

ifndef::env-slides[]
The result returned is:
endif::[]

image::MatrixRelationshipTypes.png[MatrixRelationshipTypes,width=600,align=center]


ifdef::env-slides[]
[.instructor-notes]
--
To retrieve a relationship type - I’ll introduce our first function.

The query has been *modified* from the previous slide - to return the relationship type -

* that is identified for each matched *pattern*.
* This is done using a *variable ‘rel’* - in the *anonymous relationship*.
* It is an *anonymous* relationship, since we don't specify a type in the MATCH statement.
* The ‘rel’ variable provides a way to *access* - the *relationship type* - later in the query.

For the *output* -we’ll return the names of the *people*, ...

* and the *relationship type* - using the *type function*.

The *type function* takes as an *argument*, which has a *set of relationships*.

* These relationships are in the variable - ‘rel’.
* As seen in the output, we now see the *person* and the *type* of the relationship
** - that they have - to the movie.

From our earlier example, if you returned the relationship with Tom Hanks,

* It would expose - that Tom Hanks - DIRECTED and ACTED-IN - ‘That Thing You Do’.

At this point .. we've added *relationships* to our understanding,

* We've worked with both relationship *direction* and relationship *types*.

Now let’s look at *relationship properties*.

<more details>

Here is an example where we use the rel variable to hold the relationships retrieved. We then use this variable to return the relationship types.
--
endif::[]

== Properties for relationships

ifndef::env-slides[]
Recall that a node can have as set of properties, each identified by its property key.
Relationships can also have properties.
This enables your graph model to provide more data about the relationships between the nodes.

Here is an example from the _Movie_ graph.
The movie, _The Da Vinci Code_ has two people that reviewed it, _Jessica Thompson_ and _James Thompson_. Each of these _Person_ nodes has the _REVIEWED_ relationship to the _Movie_ node for _The Da Vinci Code_.
Each relationship has properties that further describe the relationship using the _summary_ and _rating_ properties.
endif::[]

image::REVIEWEDProperties.png[ReviewedProperties,width=900,align=center]


ifdef::env-slides[]
[.instructor-notes]
--
To get started - let’s see how we can use -

* *properties* of *relationships* as *filters* and in *outputs*.

In this example - we have two *Person Nodes*.

* Each of the Nodes - has a *reviewed relationship* - with a Movie.
* Each relationship has a couple of properties.
* The  *summary property*, on what the reviewer wrote, -
** and  a *rating property*, that holds a *score* out of 100
** that the reviewer gave to this film.

It's important to understand why these *properties* are *on* the *relationship* ...

* and *not* properties on the Person or Movies *nodes*.
* The *reviewer* - makes many reviews -
** so to put that information in the Node ... would not make sense.
* It's an attribute - of the review relationship -
** between the Person and Movie nodes.

<more details>

Recall that a node can have as set of properties, each identified by its property key. Relationships can also have properties. This enables your graph model to provide more data about the relationships between the nodes. Here is an example from the Movie graph. The movie, The Da Vinci Code has two people that reviewed it, Jessica Thompson and James Thompson. Each of these Person nodes has the REVIEWED relationship to the Movie node for The Da Vinci Code. Each relationship has properties that further describe the relationship using the summary and rating properties.null
--
endif::[]


== Filtering using relationship properties

ifndef::env-slides[]
Just as you can specify property values for filtering nodes for a query, you can specify property values for a relationship. This query returns the name of of the person who gave the movie a rating of _65._
endif::[]

[source,Cypher,role=noplay]
----
MATCH (p:Person)-[:REVIEWED {rating: 65}]->(:Movie {title: 'The Da Vinci Code'})
RETURN p.name
----

ifndef::env-slides[]
The result returned is:
endif::[]

image::ReturnPersonRating65.png[ReturnPersonRating65,width=800,align=center]

ifdef::env-slides[]
Find all people that gave the movie ‘The Da Vinci Code’ a rating of 65 and return their names.
[.instructor-notes]
--
The good news is that  *relationship properties* ...

* work In exactly the same way - as *node properties*.
* If you want to use a property as a filter,
** you use the same syntax, - curly braces, as shown here.
* This is followed by -
** the property key, a colon, a space, and then the value.

In this *query* we're looking for *all people* - who rated the *movie* - ‘The Da Vinci Code’,

* That has a score of *exactly 65*.

There is only have one person returned, ‘James Thompson’.

Are there any questions about this?

Q: For a relationship, can we put in a property and not specify the relationship type?

A: The problem with doing that - is in the area of performance.

* *Relationship types* - are one of the cheapest most accessible pieces of information,
* ... along with *relationship direction*. You should use them as often as you can.

Q: Is there a *cost* to specifying *variable names everywhere*?

A: *There is* a cost.

* When you are *executing complex Cypher statements*, ...
* there are *certain clauses* that *break* the *scope* of variables  -
* and certain clauses that *don’t break* the *scope*, where a *variable* carries through.

Whenever you have a *function* that *breaks the scope* of a variable, it doesn't matter, since all of the *memory* that was set aside for that variable is *released*.

* *But* in between those breaking functions, every *variable* that you keep is going to *reserve* some memory for that variable.

As a result, when you *move* to *production* ...

* it's generally a best practice to only include variables that are needed.
* This would be for variables that you're going to use for processing or to return information.
* As in the example - shown here, a variable is only used for Person, since the variable is used later in the query.
* Having variables has nothing to do with query speed, ...
** but it will - affect the amount of resources you use.
* Usually the - resources will not take up much space, ...
** but it will depend on the questions you're asking, and the volume of overall query traffic at a given moment.

<more details>

Just as you can specify property values for filtering nodes for a query, you can specify property values for a relationship. This query returns the name of of the person who gave the movie a rating of 65.

--
endif::[]

ifdef::env-slides[]
[.section-break]
== Traversing a graph
endif::[]

== Patterns in the graph

ifndef::env-slides[]
Thus far, you have learned how to specify nodes, properties, and relationships in your Cypher queries.
Since relationships are directional, it is important to understand how patterns are used in graph traversal during query execution.
How a graph is traversed for a query depends on what directions are defined for relationships and how the pattern is specified in the `MATCH` clause.
endif::[]

Here is an example of where the _FOLLOWS_ relationship is used in the _Movie_ graph.
Notice that this relationship is directional.

image::FollowsRelationships.png[FollowsRelationships,width=400,align=center]


ifdef::env-slides[]
[.instructor-notes]
--
We haven't done much with the directional nature of relationships.

Since *relationships* are *directional*, -

* it is important to understand how *patterns* -
* are used in *graph traversal* - during query execution.

How a graph is traversed for a query depends on -

* what directions are defined for relationships -
* and how the pattern is specified in the MATCH clause.

Here we see an example of the *FOLLOWS* relationship in the Movie graph.

* Notice that this relationship is directional.
* We’ll be working with this relationship over the next few slides.

<more details>

Thus far, you have learned how to specify nodes, properties, and relationships in your Cypher queries. Since relationships are directional, it is important to understand how patterns are used in graph traversal during query execution. How a graph is traversed for a query depends on what directions are defined for relationships and how the pattern is specified in the MATCH clause.

--
endif::[]


=== Using patterns for queries

ifndef::env-slides[]
We can perform a query that returns all _Person_ nodes who follow _Angela Scope_:
endif::[]

[source,Cypher,role=noplay]
----
MATCH  (p:Person)-[:FOLLOWS]->(:Person {name:'Angela Scope'})
RETURN p
----

ifndef::env-slides[]
The result returned is:
endif::[]

image::AngelaFollowers.png[AngelaFollowers,width=600,align=center]

ifndef::env-slides[]
For this query the Person node for Angela Scope is the anchor of the query.
It is the first node that is retrieved from the graph.
Then the query engine looks for all relationships _into_ this node and retrieves them.
In this case there is only one relationship that is defined that points to the Angela Scope node, Paul Blythe.
endif::[]

image::AngelaFollowersQueryTraversal.png[AngelaFollowers,width=400,align=center]


ifdef::env-slides[]
[.instructor-notes]
--
Here we have a query that will return all Person nodes for people that FOLLOW Angela Scope.

* We need to be careful to make sure that the arrow points in the correct direction.
* As in the code shown here it points to the right,
** since we are looking for nodes that point (follow) Angela.

Let’s walk through how this query works.

* For this query the *Person node* for *Angela Scope* is the *anchor* of the query.
** The anchor is generally the node that is easiest to find, where we know more about the node.
** In this case we have a filter on the Person node.
* The anchor node is the first node that is retrieved from the graph.
* Next the query engine looks for all relationships for this node and retrieves those relationships.
* In this case there is only one relationship that is defined -
** that points to the Angela Scope node, Paul Blythe.

Are there any questions about this query or on how the anchor is identified?

<more details>

For this query the Person node for Angela Scope is the anchor of the query. It is the first node that is retrieved from the graph. Then the query engine looks for all relationships into this node and retrieves them. In this case there is only one relationship that is defined that points to the Angela Scope node, Paul Blythe.

--
endif::[]


=== Reversing the traversal

ifndef::env-slides[]
If we reverse the direction in the pattern, the query returns different results:
endif::[]

[source,Cypher,role=noplay]
----
MATCH  (p:Person)<-[:FOLLOWS]-(:Person {name:'Angela Scope'})
RETURN p
----

ifndef::env-slides[]
The result returned is:
endif::[]

image::FollowedByAngela.png[FollowedByAngela,width=700,align=center]

ifndef::env-slides[]
In this case the query engine found the Angela Scope node as the anchor and then looked for all relationships _out from_ the Angela Scope node.
endif::[]


ifdef::env-slides[]
[.instructor-notes]
--
But if it *points* to the *left*, reversing the direction in the pattern ...

* You're asking a *different* question.
* You're not asking for all *people* that *follow* Angela.
* Instead your asking who *Angela follows*, and you'll get a *different* answer.

<more details>

In this case the query engine found the Angela Scope node as the anchor and then looked for all relationships out from the Angela Scope node.

--
endif::[]


=== Querying a relationship in both directions

ifndef::env-slides[]
We can also find out what _Person_ nodes are connected by the _FOLLOWS_ relationship in either direction by removing the directional arrow from the pattern.
endif::[]

[source,Cypher,role=noplay]
----
MATCH  (p1:Person)-[:FOLLOWS]-(p2:Person {name:'Angela Scope'})
RETURN p1, p2
----

ifndef::env-slides[]
We also return the Angela Scope node so that we can see the relationships in the result. The result returned is:
endif::[]

image::AngelaFromTo.png[AngelaFromTo,width=700,align=center]


ifndef::env-slides[]
In this case the Angela Scope node is the anchor and the query engine traverses all _FOLLOWS_ relationships both in and out of the Angela Scope Node.
endif::[]

image::AngelaConnectionsQueryTraversal.png[AngelaConnectionsQueryTraversal,width=400,align=center]


ifdef::env-slides[]
[.instructor-notes]
--
Now, supposing you are interested in finding -

* *both people* that *follow Angela*
* and *people* that *Angela follows*.

In the code - the query can be modified

* to use a directionless query as shown here.
* As you can see, there is no Arrowhead on either side.
* This will RETURN - both the people she follows,
** and the people that follow her.
* Again, In this case we’re ignoring direction.

Note that we are returning p2, in addition to p1, -

* so that we can see the node for Angela in the returned nodes.
* We see the result of querying in both directions in the lower left -
** With one node for each direction.

In summary, - be very careful with your arrow heads -

* or you may not be returning the data that you expect.

*Q*: - Why was James Thompson not found?

*A*: This is answered on the next slide.

<more details>

We can also find out what Person nodes are connected by the FOLLOWS relationship in either direction by removing the directional arrow from the pattern.
In this case the Angela Scope node is the anchor and the query engine traverses all FOLLOWS relationships both in and out of the Angela Scope Node.

--
endif::[]


=== Traversing multiple relationships

ifndef::env-slides[]
Since we have a graph, we can traverse through nodes to obtain relationships further into the traversal.

For example, we can write a Cypher query to return all followers of the followers of _Jessica Thompson_.
endif::[]

[source,Cypher,role=noplay]
----
MATCH  (p:Person)-[:FOLLOWS]->(:Person)-[:FOLLOWS]->(:Person {name:'Jessica Thompson'})
RETURN p
----

ifndef::env-slides[]
The result returned is:
endif::[]

image::FollowersOfJessicaFollowers.png[FollowersOfJessicaFollowers,width=800,align-center]


ifndef::env-slides[]
For this query the _Jessica Thompson_ node is the anchor.
Then from the Jessica Thompson node, the query engine looks for any relationships into that node.
It finds two, but then it must traverse more to find the next FOLLOWS relationship (if any) out of the found nodes.
It finds only one node, _Paul Blythe_ that matches the query.
endif::[]

image::FollowersOfFollowersQueryTraversal.png[FollowersOfFollowersQueryTraversal,width=300,align=center]


ifdef::env-slides[]
Query to return all followers of the followers of Jessica Thompson
[.instructor-notes]
--
(Answer to previous slide – *Q*: Why was James Thompson not found?)
A:  The reason, James Thompson does not show up in the answer is based on how the query is written.

* If we break down - what we’re looking for in the structure, ...
* we're *looking for* - a *pattern* with -  *one* node, *one* relationship, and *another* node.
* So the answer is in the pattern.
* In order to RETURN - James Thompson - we need a *longer pattern*.

<START HERE>

So far, we've worked with *relatively simple patterns* -

* where the structure we're looking for has - *two nodes* in *one relationship*.

There is *no limitation* - on the *length of a pattern* - that you can request in Neo4j.

* For example, here we're looking for - *second degree followers* - for Jessica Thompson.
* That is - we’re *looking* for -
** a *person* that follows a *person* - that follows a *person* ...,
** where that last person's name - in this  pattern - is Jessica Thompson. .

On the right - we see a visualization of the part of the graph being searched.

* We're looking for person follows > person follows > Jessica Thompson.
* We see that - there is one match - where *Paul* follows *Angela*, and *Angela* follows *Jessica*.
* Therefore this query returns Paul Blythe

After seeing this - it becomes clear that  you need to be very careful in your MATCH statement  ...

* to code a pattern - that will return the answer to your question.
* This requires that you precisely define the pattern, …
** taking into account its length, its features,
** the directions of the relationship.

There’s no theoretical upper limit - to the complexity of the pattern.

Are there any other questions about patterns at this time?

Q: How do we know how deep we want to go in a pattern.

A: That will depend on the question and the data model.

* One thing that will help in this - we will be discussing soon - on how you can work with a variable length path.

Since we have a graph, we can traverse through nodes to obtain relationships further into the traversal.

<more details>

For this query the Jessica Thompson node is the anchor. Then from the Jessica Thompson node, the query engine looks for any relationships into that node. It finds two, but then it must traverse more to find the next FOLLOWS relationship (if any) out of the found nodes. It finds only one node, Paul Blythe that matches the query.

--
endif::[]

ifndef::env-slides[]
=== Variation on the traversal

This query could also be modified to return each person along the matched path by specifying variables for the nodes and returning them.
For example:


[source,Cypher,role=noplay]
----
MATCH  (p:Person)-[:FOLLOWS]->(p2:Person)-[:FOLLOWS]->(p3:Person {name:'Jessica Thompson'})
RETURN p.name, p2.name, p3.name
----

For this query, although the query engine traverses the path from _Jessica Thompson_ to _James Thompson_, it finds that the _James Thompson_ node does not match the entire path specified.

The result returned is:

image::NodesInPathForFollowersOfJessicaFollowers.png[NodesInPathForFollowersOfJessicaFollowers,width=1000,align=center]
endif::[]

=== Using patterns to focus the query

ifndef::env-slides[]
As you gain more experience with Cypher, you will see how patterns in your queries enable you to focus on the relationships in the graph.
For example, suppose we want to retrieve all unique relationships between an actor, a movie, and a director.
This query will return many unique rows of information that provide this pattern in the graph:
endif::[]

[source,Cypher,role=noplay]
----
MATCH (a:Person)-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-(d:Person)
RETURN a.name, m.title, d.name
----

ifndef::env-slides[]
The result returned is:
endif::[]

image::TraversalInTwoDirections.png[TraversalInTwoDirections,width=800,align=center]

ifndef::env-slides[]
In this query, notice that there are multiple records returned for a movie, each with its set of values for the actor and director.
Each row is unique since the focal point of the query is the actor/director for a particular movie.
endif::[]


ifdef::env-slides[]
[.instructor-notes]
--
This query shows an example of using a *longer pattern* ...

* where the *Movie node* is in the *middle* -
** and it locates Person nodes - that will *return* …
** the *movie*, the *actors* in the movie, and the *directors* for the movie.

The return values have duplication.

* Later - we’ll look at how to remove duplication -
* in the returned data set.

(*Note*: Point out that there are duplicate rows returned - will learn about DISTINCT later.)

<more details>

As you gain more experience with Cypher, you will see how patterns in your queries enable you to focus on the relationships in the graph. For example, suppose we want to retrieve all unique relationships between an actor, a movie, and a director. This query will return many unique rows of information that provide this pattern in the graph:
In this query, notice that there are multiple records returned for a movie, each with its set of values for the actor and director. Each row is unique since the focal point of the query is the actor/director for a particular movie.

--
endif::[]


== Returning paths

ifndef::env-slides[]
In addition, you can assign a variable to the path and return the path as follows:
endif::[]

[source,Cypher,role=noplay]
----
MATCH  path = (:Person)-[:FOLLOWS]->(:Person)-[:FOLLOWS]->(:Person {name:'Jessica Thompson'})
RETURN  path
----

ifndef::env-slides[]
The result returned is:
endif::[]

image::ReturnPath.png[ReturnPath,width=1100,align=center]


ifdef::env-slides[]
[.instructor-notes]
--
You can return the entire path by assigning a variable as shown here.
--
endif::[]


=== Returning multiple paths

ifndef::env-slides[]
Here is another example where multiple paths are returned.
The query is to return all paths from actors to a movie that was directed by Ron Howard
endif::[]

[source,Cypher,role=noplay]
----
MATCH  path = (:Person)-[:ACTED_IN]->(:Movie)<-[:DIRECTED]-(:Person {name:'Ron Howard'})
RETURN  path
----

ifndef::env-slides[]
Multiple paths are returned. Even if we set Neo4j Browser to not connect result nodes, the nodes are shown as connected in the visualization because we are returning paths, not nodes:
endif::[]

image::ReturnRonHowardPaths.png[ReturnRonHowardPaths,width=800,align=center]

ifndef::env-slides[]
[NOTE]
A best practice is to specify direction in your `MATCH` statements. This will optimize queries, especially for larger graphs.

Later in this course, you will learn other ways to query data and how to control the results returned.
endif::[]


ifdef::env-slides[]
Best practice:

[square]
* Specify direction in MATCH statements
** It optimizes queries, especially for larger graphs
[.instructor-notes]
--
In this example multiple paths are saved to a variable and then returned.

The returns query all paths

* from actors to movies  directed by Ron Howard.

Even if we set Neo4j Browser to not connect result nodes,

* the nodes are shown as connected in the visualization
* because we are returning paths, not nodes:

Later in this course, you will learn other ways to query data and how to control returned results.

--
endif::[]

ifdef::env-slides[]
[.section-break]
== Cypher recommendations
endif::[]

ifndef::env-slides[]
== Cypher style recommendations

Here are the *Neo4j-recommended* Cypher coding standards that we use in this training:

[square]
* Node labels are CamelCase and begin with an upper-case letter (examples: _Person_, _NetworkAddress_). Note that node labels are case-sensitive.
* Property keys, variables, parameters, aliases, and functions are camelCase and begin with a lower-case letter (examples: _businessAddress_, _title_). Note that these elements are case-sensitive.
* Relationship types are in upper-case and can use the underscore. (examples: _ACTED_IN_, _FOLLOWS_). Note that relationship types are case-sensitive and that you cannot use the "-" character in a relationship type.
* Cypher keywords are upper-case (examples: `MATCH`, `RETURN`). Note that Cypher keywords are case-insensitive, but a best practice is to use upper-case.
* String constants are in single quotes, unless the string contains a quote or apostrophe (examples: _'The Matrix'_, _"Something's Gotta Give"_). Note that  you can also escape single or double quotes within strings that are quoted with the same using a backslash character.
* Specify variables only when needed for use later in the Cypher statement.
* Place named nodes and relationships (that use variables) before anonymous nodes and relationships in your `MATCH` clauses when possible.
* Specify anonymous relationships with `+-->+`, `--`, or `+<--+`.
endif::[]


ifdef::env-slides[]
== Cypher style recommendations (1 of 2)

[square]
* Names, except for keywords are case-sensitive.
* Node labels are CamelCase and begin with an upper-case letter.
* Property keys, variables, parameters, aliases, and functions are camelCase and begin with a lower-case letter.
* Relationship types are in upper-case and can use the underscore.

[.instructor-notes]
--
To close out this section
Let's talk about - style recommendations - for Neo4j.

These recommendations are generally - about case sensitivity and conventions.

There are a few conventions that we always follow at Neo4j.

* We recommend you do the same, but it isn’t required.
* I’ve listed these conventions here.

For case sensitivity, as rule of thumb, in Neo4j is everything is case sensitive, except for Cypher keywords.

* For example  MATCH and RETURN are case sensitive.

*Node Labels* cannot contain spaces or any other kinds of space - or characters.

* We tend to use *camel case, - uppercase*.  This is *analogous* - to how you would define a *class* - in Java.

For *property keys, variables, parameters, aliases*, and other *functions*, ...

* We generally use *camel case, lowercase*.  This is what is commonly used - for *variables* and instances in Java.

For *relationship types* - we tend to use *uppercase*.

* The reason we do this - is that *underscore* - is a permitted - spacer character.
* Therefore - we don't have to use - *camel casing* - since there is  another way of marking separations.
* The reason we use - *uppercase *- for type, is that - we find it's - *more readable*.

Are there any questions about these style recommendations?

--

== Cypher style recommendations (2 of 2)
[square]
* Cypher keywords are upper-case.
* String constants are in single quotes.
* Place named nodes and relationships (that use variables) before anonymous nodes and relationships.
* Specify anonymous relationships with `+-->+`, `--`, or `+<--+`.

[.instructor-notes]
--
Here are a few more Cypher style recommendations.

For *Cypher keywords* - are not - case sensitive.

* We use - *all capitals* - just for the sake of *readability*.

For string constants, you can use either single quotes or double quotes.

* We tend to default - to single quotes - because it saves you - a press of the shift key, - but either way works.
* For consistency, one way should be selected.
* If you're string contains - one of the reserved characters, - there would be an exception.

Another recommendation is to specify variables - ...

* only when you actually need them - to avoid using unneeded storage.

The next recommendations are a little squishy.

* Put your variable nodes - in a relationship - before other nodes.
* Although, There is no  processing difference, ...
* It is recommended, since the way questions tend to be asked make the readability of the code more intuitive.

We prefer specifying anonymous relationships with out empty square brackets.

(*Note*: Show the Cypher Style Guide:  https://github.com/opencypher/openCypher/blob/master/docs/style-guide.adoc )


--
endif::[]

ifndef::env-slides[]
=== Example: Using style recommendations

Here is an example showing some best coding practices:

[source,Cypher,role=noplay]
----
MATCH (:Person {name: 'Diane Keaton'})-[movRel:ACTED_IN]->
(:Movie {title:"Something's Gotta Give"})
RETURN movRel.roles
----

We recommend that you follow the https://neo4j.com/docs/cypher-manual/current/styleguide/[Cypher Style Guide^] when writing your Cypher statements.
endif::[]

[.student-exercise]
== Exercise 3: Filtering queries using relationships

In the query edit pane of Neo4j Browser, execute the browser command:

kbd:[:play 4.0-intro-neo4j-exercises]

and follow the instructions for Exercise 3.

[NOTE]
This exercise has 5 steps.
Estimated time to complete: 15 minutes.

ifdef::env-slides[]
[.instructor-notes]
--
We’ve now covered a lot of information working with nodes, labels, properties, and relationships.

* We’ve also expanded to have a glimpse of the full complexity of patterns you can request.

It's time for exercise 3.

* You're going to add relationships to the queries with MATCH and RETURN.
* You're going to be adding a great deal of complexity relative to the earlier exercise.
* You're going to look at some binary to node relationship,
* You can look at the difference between using certain directions
* and you're going to expand out to more complex patterns such as having three nodes and two relationships.

We'll take about 25 minutes for this one.

(*Note:* Show students how to  :play 4.0-intro-exercises and how to navigate to Exercise 3.)

* As before, please let me know when you finished, or if you have any questions or difficulties.

<=== EXERCISE 3 and END OF SECTION ON CYPHER-------------->

Alright everyone, let's wrap up this exercise and carry on.

* We've covered quite a bit of territory.
* We've talked about node syntax and how to filter nodes based on labels and property values.
* We've looked at the same areas with respect to relationships ...
** using relationships and property relationships and nodes together ...
** to define complex patterns to filter relationships based on direction type and properties of their own.

Moreover, we've looked at how you can use variables and dot notation to return ...

* not only entire graph objects, but also just certain properties from the graph.

Any last questions about any of areas that we’ve covered in Cypher?

--
endif::[]


[.quiz]
== Check your understanding

=== Question 1

[.statement]
Suppose you have a graph that contains nodes representing customers and other business entities for your application.
The node label in the database for a customer is _Customer_. Each _Customer_ node has a property named _email_ that contains the customer's email address.
What Cypher query do you execute to return the email addresses for all customers in the graph?

[.statement]
Select the correct answer.

[%interactive.answers]
- [ ] [src-cypher]`MATCH (n) RETURN n.Customer.email`
- [x] [src-cypher]`MATCH (c:Customer) RETURN c.email`
- [ ] [src-cypher]`MATCH (Customer) RETURN email`
- [ ] [src-cypher]`MATCH (c) RETURN Customer.email`


ifdef::env-slides[]
[.instructor-notes]
--
*1st*, suppose you have a *graph* that contains *nodes* representing a bunch of things.

* For example you have customers and other business entities.
* We're primarily interested in our customers.
* They have a *Label* customer.
* And each one of these *nodes* has an *email property* which contains the *email address*.
* So we have the *customer label* and the *email property*.

Which of the following Cypher queries would you execute ...

* to *return* the *email addresses* for *all* customers in the graph?

Discussion –  Question 1)

A) What is wrong with the *1st* option?

* This return statement uses *two dots* in the RETURN. That's not a thing and doesn't work.
* If we just had ‘n’ dot email, we would have gotten an answer. Although we wouldn't have gotten the answer we wanted.  Since it could return emails that were not necessarily for customers (i.e. employees)  since the node does not specify a label
* There are two problems here, there is a bad return statement and an underdefined MATCH.

B) The *2nd* option is the - *correct answer*.

C) What is wrong with number *3*?

* In the RETURN the email is an undefined variable.

D)  What is wrong with number *4*?

* Customer.email will work, but it will give a bad answer.
* since Customer is a variable, not a Label since there is no :
* Also there is an undefined match with just ‘c’

--
endif::[]


=== Question 2

[.statement]
Suppose you have a graph that contains _Customer_ and _Product_ nodes. A _Customer_ node can have a _BOUGHT_ relationship with a _Product_ node.
_Customer_ nodes can have other relationships with _Product_ nodes.
A _Customer_ node has a property named _customerName_.
A _Product_ node has a property named _productName_.
What Cypher query do you execute to return all of the products (by name) bought by customer 'ABCCO'.

[.statement]
Select the correct answer.

[%interactive.answers]
- [ ] [src-cypher]`MATCH (c:Customer {customerName: 'ABCCO'}) RETURN c.BOUGHT.productName`
- [ ] [src-cypher]`MATCH (p:Product)<-[:BOUGHT]-(:Customer 'ABCCO') RETURN p.productName`
- [ ] [src-cypher]`MATCH (p:Product)<-[:BOUGHT_BY]-(:Customer 'ABCCO') RETURN p.productName`
- [x] [src-cypher]`MATCH (p:Product)<-[:BOUGHT]-(:Customer {customerName: 'ABCCO'}) RETURN p.productName`


ifdef::env-slides[]
[.instructor-notes]
--

Correct answer(s) 4:
- MATCH (:Customer {customerName: 'ABCCO'})-[:BOUGHT]→(p:Product) RETURN p.productName

*Question 2*. This is one is slightly more complex.

* You're working with a graph that has customer and product Nodes.
* *Customer nodes* can have a *BOUGHT relationship* with products , among other types of relationships.
* *Customer nodes* have a *customerName* property.
* *Product node*s have a *productName* property.
* Based on these - *Customer* and *Product Labels*, customers *BOUGHT* products using that type of relationship.

Which of these Cypher queries will return all of the products, bought by customer ABC Co. ?
Discussion –  Question 2)

A) The 1st one does not specify a pattern of a customer that bought a product.

* Also the return statement has the wrong format with three dots.

B)  The 2nd is incorrect since the property does not have the curly braces or the property identifier.

C)  The 3rd option has the same problem as 2nd with bad property specifier.

* Also the property is not BOUGHT_BY, it is BOUGHT.

D)  The 4th option is correct.

--
endif::[]


=== Question 3

[.statement]
Thus far, you have learned to use a simple MATCH clause to return values. When [.underline]#must# you use a variable in a simple MATCH clause?

[.statement]
Select the correct answer.

[%interactive.answers]
- [ ] When you want to query the graph using a node label.
- [ ] When you specify a property value to match the query.
- [x] When you want to use the node or relationship to return a value.
- [ ] When the query involves 2 types of nodes.

ifdef::env-slides[]
[.instructor-notes]
--
Correct answer(s) 3:
- When you want to use the node or relationship to return a value.

Our last question is - When must you use a variable in a match clause.

* When you want to query using node labels.
* When you want to query using a property.
* When you want to return the node or a relationship in a result,
* or When a query involves two different labels, two different types of nodes.

You only need to a variable in a MATCH clause - when you MUST use it in the query after the initial MATCH.

--
endif::[]

[.summary]
== Summary

You should now be able to write Cypher statements to:
[square]
* Retrieve nodes from the graph.
* Filter nodes retrieved using property values of nodes.
* Retrieve property values from nodes in the graph.
* Filter nodes retrieved using relationships.

