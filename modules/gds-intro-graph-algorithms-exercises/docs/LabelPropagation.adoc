= Label Propagation
:icons: font

== Label Propagation (Preparations)

The database you start with should contain all of the data you loaded in the setup for this course.

This is what you should see when you click the database icon image:database-icon.png[].

image::LoadedDatabase.png[LoadedDatabase,width=150]

{nbsp} +

If you do not see this in your Neo4j Browser, you will need to perform the setup steps again.

== Label Propagation (Graph Catalog)

The projected graph *roads* should be created and stored in the GDS graph catalog.

This is what you should see when you execute the following query:

[source, cypher]
----
CALL gds.graph.list()
YIELD graphName, nodeCount, relationshipCount
----

image::LoadedRoadsGraph.png[LoadedDatabase]

If you do not see this in your Neo4j Browser, you will need to perform the graph catalog steps again.

== Label Propagation (Overview)

In the Weakly Connected components exercise, you used the weakly connected components algorithm to write component information to each *Place* node.
This property was named *wcc_component*. In this exercise, you will gain some experience with writing Cypher to implement the Label Propagation algorithm using the European Roads dataset.
This algorithm enables you to determine discreet sets of nodes that form clusters based upon how they are connected, as well as the weight of the connections.

In this exercise, you will:

* *Part 1*: Stats mode
* *Part 1*: Inspect the weight statistics
* *Part 2*: Stats mode
* *Part 3*: Add a community property to each node using Label Propagation.
* *Part 4*: Verify the results of executing the algorithm.

Go to the next page to start this exercise.

== Stats mode

CALL gds.labelPropagation.stats('roads')
YIELD communityCount, communityDistribution
RETURN communityCount, communityDistribution

== Part 1: Inspect weight statistics (Instructions/Solution)

*Hint*: You will use `apoc.agg.statistics`.

[source, cypher]
----
UNWIND ['distance','inverse_distance'] as prop
MATCH (:Place)-[r:EROAD]->(:Place)
WITH prop, apoc.agg.statistics(r[prop]) as stats
RETURN prop, stats.total as total, stats.min as min, stats.max as max,
       stats["0.5"] as p50, stats["0.75"] as p75, stats["0.9"] as p90,
       stats["0.95"] as p95, stats.stdev as stdev
----

Values of *distance* property are in kilometers. More than half of the distances are below 100km.
The longest road connecting Moskva and Rostov-na-Donu is 1066km long.
On the other hand, most of the *inverse_distance* values have a value of less than 0.02.

The results returned should look like this:

== Weighted Stats mode

CALL gds.labelPropagation.stats('roads',
   {relationshipWeightProperty:'inverse_distance'})
YIELD communityCount, communityDistribution
RETURN communityCount, communityDistribution

What enormous difference does it make!


== Part 1: Add a community property to each node using Label Propagation. (Instructions)

Write Cypher code to perform the Label Propagation algorithm on the European road network using these guidelines:

* The algorithm will perform a maximum of 10 iterations.
* The analysis will be done *roads* network we projected in the Graph Catalog section.
* The algorithm will write a property named *community_lpa* to each node with the computed value.
* The weight property name is *inverse_distance*.

*Hint*: You will call `gds.labelPropagation.write`.

== Part 1: Add a community property to each node using Label Propagation. (Solution)

Write Cypher code to perform the Label Propagation algorithm on the European road network using these guidelines:

* The algorithm will perform a maximum of 10 iterations.
* The analysis will be done *roads* network we projected in the Graph Catalog section.
* The algorithm will write a property named *community_lpa* to each node with the computed value.
* The weight property name is *inverse_distance*.

*Hint*: You will call `gds.labelPropagation.write`.

Here is the solution code:

[source, cypher]
----
CALL gds.labelPropagation.write('roads',{
    maxIterations: 10,
    writeProperty: "community_lpa", 
    relationshipWeightProperty: "inverse_distance" })
----

The results returned should look like this:

[.thumb]
image::EX4.1.png[EX4.1,width=400]

== Part 2: Verify the results of executing the algorithm. (Instructions)

Write a query to return all *community_lpa* values in the graph containing *Place* nodes.
For each distinct community value, return the list of places and the size of the community.

== Part 2: Verify the results of executing the algorithm. (Solution)

Write a query to return all *community_lpa* values in the graph containing *Place* nodes.
For each distinct community value, return the list of places and the size of the community.

Here is the solution code:

[source, cypher]
----
MATCH (node:Place)
RETURN node.community_lpa as communityId,
       count(*) as communitySize,
       collect(node.name) AS places
ORDER BY communitySize DESC 
LIMIT 10
----

The results returned should look like this:

[.thumb]
image::EX4.2.png[EX4.2,width=400]

== Label Propagation: Taking it further

. Try using the stream version of the algorithm.
. Try different configuration values, for example number of iterations.
. Try using the *seedProperty* parameter.

== Label Propagation (Summary)

In this exercise, you gained some experience with writing Cypher to implement the Label Propagation algorithm using the European Roads dataset.
This algorithm enables you to determine discreet sets of nodes that form clusters based upon how they are connected, as well as the weight of the connections.

